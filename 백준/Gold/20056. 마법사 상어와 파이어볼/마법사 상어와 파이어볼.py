from collections import deque

# 격자 가로세로 길이 N, 파이어볼 개수 M, 이동 회수 K 입력받고 각 변수에 저장
N, M, K = map(int, input().split())

# 마법사 상어의 파이어볼의 위치(r, c), 질량(m), 방향(d), 속력(s) 각각 M만큼 입력받아 deque arr에 저장
arr = deque([list(map(int, input().split())) for _ in range(M)])


# 파이어볼은 현재 위치한 칸과 인접한 8개의 칸(가로, 세로, 대각선)으로 이동함
# 딕셔너리 통해 각기 현재 인덱스, 0~7번 이동방향 지정
# 굳이 현재 인덱스 번호까지 넣은 이유는 파이썬 규칙을 따르기 위함임
route = {
    "0" : [-1, 0],
    "1" : [-1, 1],
    "2" : [0, 1],
    "3" : [1, 1],
    "4" : [1, 0],
    "5" : [1, -1],
    "6" : [0, -1],
    "7" : [-1, -1],
}

# 이동회수 K만큼 반복함
for k in range(K):
    # 파이어볼의 현 상황(어느 칸에 위치하는지, 몇 개의 파이어볼과 함께 있는지) 담아줄 2차원 리스트 space 생성
    # 입력으로 주어지는 파이어볼의 현재 좌표는 파이썬 규칙(0부터 시작)과는 달리 첫 인덱스 값이 1부터 시작되므로, 아예 격자도 N+1길이로 생성해줌
    space = [[list() for _ in range(N + 1)] for _ in range(N + 1)]

    # arr가 빌 때까지 반복, arr에 가장 왼쪽에 담긴 파이어볼의 정보를 꺼내서 변수 a에 저장함
    # 만약 a[2](질량)가 0이라면, 해당 파이어볼은 이미 소멸된 상태이므로 반영하지 않음
    while arr:
        a = arr.popleft()
        if a[2] == 0:
            pass
    # 만약 소멸되지 않은 파이어볼이라면, 이하 연산 진행
    # 먼저 a[4](방향) 값 이용해 route에서 이동방향을 꺼내와 gothere 변수에 저장
    # 변수 i, j에 현재 위치 값 a[0], a[1](r, c) 값 저장
        else:
            gothere = route[str(a[4])]
            i, j = a[0], a[1]
            # 그냥 값 지정해줬더니 자꾸 오류나서 ㅠㅜ 쓰고 싶지 않았지만 for문 씀...머리 좋으시면 그대는 이런 수단을 쓰지 않아도 값 변경을 하실 수 있으실 겁니다(찡긋)
            # 속력(a[3], s)만큼 for문 통해서 반복
            # i, j 값을 gothere의 해당 인덱스를 통해 속력만큼 반복하며 변형해줌
            for _ in range(a[3]):
                i += gothere[0]
                j += gothere[1]
                # 본 격자는 1과 N값이 이어져 있음. 즉, 0일 시 N으로 값을 변경해주고, N+1일시 1로 값을 변경해줄 필요가 있음
                # 4중 if문을 통해 조건 걸어둠(i와 y는 따로 취급)
                if i == N + 1:
                    i = 1
                if i == 0:
                    i = N
                if j == N + 1:
                    j = 1
                if j == 0:
                    j = N
            # 모든 연산이 끝나면, space의 해당 좌표에 들어있는 리스트에 해당 파이어볼의 질량, 속력, 방향이 들어간 리스트를 추가해줌
            # 굳이 이 세 정보를 넣는 것은 만약 해당 좌표에 위치한 파이어볼이 2개 이상일 시, 병합 및 분리 작업이 이행되어야 하기 때문임(이 때 필요한 정보가 저 3 정보)
            space[i][j].append([a[2], a[3], a[4]])

    # 2중 for문을 이용해 space를 순회하며 파이어볼 유무를 확인함
    # x나 y 중 둘 중 하나만 0으로 값을 가져도 해당 좌표에 담긴 파이어볼은 없으므로 계산 줄여주기 위해 range 범위를 1부터 지정함
    for x in range(1, N + 1):
        for y in range(1, N + 1):
            # space의 해당 좌표에 담긴 리스트를 fireballs 변수에 저장
            fireballs = space[x][y]
            # 만약 길이가 0이라면, 즉 파이어볼이 없다면 패스함
            # 만약 길이가 1이라면 파이어볼 개수가 1개이므로 병합 분리 시행하지 않고 해당 좌표, 질량, 속력, 방향이 들어간 리스트를 arr에 추가해줌
            if len(fireballs) == 0:
                pass
            elif len(fireballs) == 1:
                arr.append([x, y, fireballs[0][0], fireballs[0][1], fireballs[0][2]])
            # 위 조건 두 개에 해당하지 않는다면, 해당 좌표에 위치한 파이어볼의 개수는 2개 이상임
            # 병합 및 분리 과정을 시행함
            else:
                # 모든 파이어볼의 질량을 담아줄 mass, 속력을 담아줄 speed, 그리고 방향이 모두 홀수 or 짝수인지, 혹은 번갈아서 나오는지를 검증할 check 변수를 생성
                mass, speed, check = 0, 0, 0
                # 만약 모든 파이어볼의 방향이 홀수 또는 짝수로 일괄적이지 않을 시 지정될 방향을 리스트 형태로 만들어 reroute 변수에 지정해둠(초기값)
                reroute = [1, 3, 5, 7]
                # for문을 통해 fireballs 리스트 내에 들어있는 fireball을 검증
                # 질량, 속력을 mass와 speed에 저장해준 후, check에 해당 방향에서 2를 나눈 후 나머지를 더해줌
                for fireball in fireballs:
                    mass += fireball[0]
                    speed += fireball[1]
                    check += (fireball[2] % 2)
                
                # 모든 파이어볼을 확인하고 연산 진행한 후, 질량은 '합쳐진 파이어볼 질량의 합/5', 속력은 '속력의 합/파이어볼 개수'이므로 해당 값 연산해서 재지정해줌 
                mass, speed = (mass // 5), (speed // len(fireballs))

                # 이제 방향 검증을 진행할 것임
                # 만약 모든 방향이 짝수였다면 나머지가 모두 0일 것이므로 check가 값이 0일 것임
                # 반대로 모두 홀수였다면 모든 파이어볼 방향의 나머지가 1이었을 것이므로 파이어볼의 개수와 check 값이 동일했을 것임
                # 만약 둘 중 하나의 조건을 충족한다면 파이어볼의 방향을 모두 짝수로 바꾸도록 재지정해주고, 아니라면 기존 초기값(홀수)을 유지함
                if check == 0 or check == len(fireballs):
                    reroute = [0, 2, 4, 6]
                
                # 병합된 파이어볼은 다음 턴에서 4방향 4개로 분할되어 이동함
                # for문 통해 4번 반복하며 파이어볼의 현 좌표, 방금 연산에서 구한 무게와 속력, 그리고 각 방향을 담은 리스트를 arr에 추가해줌
                for i in range(4):
                    arr.append([x, y, mass, speed, reroute[i]])

# 모든 이동이 끝난 후, 남은 파이어볼의 질량을 계산함
# total 변수 생성한 후, arr를 순회하며 현재 존재하는 각 파이어볼의 질량만 뽑아내어 total에 더해줌
total = 0
for a in arr:
    total += a[2]

# 최종 연산까지 마친 후, 정답을 출력함
print(total)